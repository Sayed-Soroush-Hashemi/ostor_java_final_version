\documentclass{article}

\usepackage[
	left=2cm, 
	right=2cm, 
	top=2.5cm, 
	bottom=2.5cm, 
	columnsep=20pt
]{geometry} % for setting paper and columns margins
\usepackage[extrafootnotefeatures]{xepersian}

\settextfont[Scale=1.1]{XB Niloofar}
\setlatintextfont{Times New Roman}
\baselineskip=6mm
\renewcommand{\baselinestretch}{1.7} 

\title{گزارش بخش دوم فاز دوم پروژه سیستم عامل}
\author{سید سروش هاشمی\\الناز مهرزاده\\بهار سلامتیان}
\date{\today}

\begin{document}
\maketitle
\section{نحوه اجرا}
برای اجرا کافی است فایل 
\lr{Main.java} 
در 
\lr{src} 
را کامپایل و اجرا کنید. 
\section{معماری نرم‌افزار}
این نرم‌افزار حاوی سه 
\lr{package} 
اصلی است. یک 
\lr{package} 
مربوط به سخت‌افزار است که شامل کلاس‌هایی مانند 
\lr{CPU}، 
\lr{Core}، 
\lr{ALU}
و
\lr{MotherBoard}
است. 
\lr{package} 
دیگر مربوط به سیستم عامل است. در این 
\lr{package} 
کلاس‌های مربوط به فعالیت‌های سیستم عامل از جمله 
\lr{OS}، 
\lr{Process}، 
\lr{Thread}، 
\lr{Scheduler}
و
\lr{Channel}
قرار دارند. 
\lr{package} 
سوم مربوط به 
\lr{Compiler} 
است. 

در ادامه  توضیح مختصری درباره روند کار نرم‌افزار می‌دهیم. 

\subsection{روند بالا آمدن سیستم عامل، اجرای پردازه‌ها و خاموش شدن سیستم عامل}
ابتدا یک شی از کلاس 
\lr{MotherBoard} 
ساخته می‌شود. 
\lr{MotherBoard} 
تمام سخت‌افزارهای لازم را 
\lr{new} 
می‌کند. مثلا یک 
\lr{CPU} 
می‌سازد، یک 
\lr{Screen} 
برای نمایش خروجی‌ها به کاربر می‌سازد، و در فازهای بعدی 
\lr{MainMemory} 
و 
\lr{SecondaryMemory} 
خواهد ساخت. بعد از ساخت سخت‌افزارها، اقدام به 
\lr{boot} 
کردن سیستم‌عامل می‌کند. در فرایند 
\lr{boot} 
کردن، سخت‌افزارهایی که سیستم‌عامل برای انجام فعالیت‌های خود به آن‌ها نیاز دارد را به کلاس 
\lr{OS} 
معرفی می‌کند. مثلا 
\lr{CPU} 
و 
\lr{Screen} 
را به 
\lr{OS} 
معرفی می‌کند و درفازهای آینده 
\lr{MainMemory} 
و 
\lr{SecondaryMemory} 
را معرفی خواهد کرد. بعد از 
\lr{boot} 
کردن سیستم‌عامل، 
\lr{CPU} 
شروع به فعالیت می‌کند. چون امکان استفاده از 
\lr{Thread} 
را نداریم، 
\lr{CPU} 
بین تک تک 
\lr{Core}
ها گردش می‌کند و به هر کدام می‌گوید که یک 
\lr{instruction} 
اجرا کنند. به طور دقیق‌تر، وقتی 
\lr{MotherBoard} 
عمل 
\lr{boot} 
کردن سیستم‌عامل را تمام می‌کند، تابع 
\lr{run} 
در 
\lr{CPU} 
را فراخوانی می‌کند. این تابع بین تمام 
\lr{Core} 
ها گردش می‌کند و از هر کدام یک 
\lr{instruction} 
اجرا می‌کند و در پایان هر یک دور گردش، از سیستم‌عامل سوال می‌کند که آیا قصد خاموش شدن دارد یا خیر. در صورتی که سیستم‌عامل قصد خاموش شدن نداشته باشد، 
\lr{CPU} 
به کارش ادامه می‌دهد. در غیر این صورت، 
\lr{CPU} 
متوقف می‌شود. 

هر 
\lr{Core} 
یک 
\lr{Thread} 
و یک 
\lr{timer} 
دارد. وقتی یک 
\lr{Core} 
قرار است یک 
\lr{instruction} 
اجرا کند، از 
\lr{thread} 
خود می‌خواهد که 
\lr{instruction} 
بعدی را بدهد. اگر 
\lr{thread} 
دیگر هیچ 
\lr{instrcution} 
نداشت، یا در حالت انتظار بود، یا 
\lr{terminate} 
شده بود، یا 
\lr{timer} 
به صدا در آمده باشد یا 
\lr{core} 
هیچ 
\lr{thread} 
نداشت، به سیستم‌عامل 
\lr{interrupt} 
می‌دهد و سیستم‌عامل در صورتی که 
\lr{thread} 
برای اجرا داشت، آن را به 
\lr{core} 
می‌دهد. به طور مثال اگر ۸ 
\lr{core} 
داشته باشیم، در اول کار فقط یکی از آن‌ها مشغول فعالیت است و بقیه هیچ 
\lr{thread} 
ندارند تا زمانی که یک 
\lr{thread} 
دیگر ساخته شود. نتیجه تمام این 
\lr{interrupt} 
ها عوض شدن 
\lr{thread} 
در 
\lr{core} 
است که سیستم‌عامل آن را با کمک 
\lr{Scheduler} 
انجام می‌دهد. 

حال فرض کنید 
\lr{core} 
می‌خواهد یک 
\lr{instruction} 
را اجرا کند. این 
\lr{instruction} 
ممکن است 
\lr{System Call} 
باشد یا نباشد. در حالت اول 
\lr{Core} 
به سیستم‌عامل مراجعه می‌کند و در حالت دوم خودش دستور را اجرا می‌کند. 

بنابراین در کل ۲ نوع پیام بین 
\lr{Core} 
و سیستم‌عامل رد و بدل می‌شود. یک نوع 
\lr{interrupt} 
ها هستند و نوع دیگر 
\lr{System Call} 
ها. 

وقتی می‌خواهیم یک 
\lr{program} 
را اجرا کنیم، ابتدا آن را کامپایل می‌کنیم. برای این کار از 
\lr{package} 
مربوط به 
\lr{compile} 
استفاده می‌کنیم. 
\lr{compiler} 
ما فایل را می‌خواند و همان طور که در فاز قبلی توضیح دادیم، تمام دستورات شرطی و حلقه‌ها را به تعدادی 
\lr{conditional jump} 
تبدیل می‌کند. به طور دقیق‌تر در ابتدا، کامپایلر فایل را 
\lr{parse} 
می‌کند و دستورات را از هم جدا می‌کند و شرط‌ها و حلقه‌ها را به 
\lr{conditional jump} 
ها تبدیل می‌کند. سپس کامپایلر از دستورات 
\lr{parse} 
شده، 
\lr{instruction}
هایی که برای سخت‌افزار قابل فهم است می‌سازد. یک کلاس 
\lr{abstract} 
به نام 
\lr{instruction} 
در 
\lr{package} 
سخت افزار قرار دارد. سخت‌افزار فقط و فقط دستورات موجود در پوشه 
\lr{hardware.cpu.instruction} 
را پشتیبانی می‌کند. بنابراین کامپایلر از دستورات 
\lr{parse} 
شده یک دنباله از اشیاء از نوع 
\lr{instruction} 
می‌سازد که قرار است 
\lr{Core} 
آن‌ها را اجرا کند. 

وظیفه 
\lr{package} 
سیستم‌عامل پاسخ‌دادن به 
\lr{interrupt} 
ها و 
\lr{System Call} 
هاست. همچنین وظیفه مدیریت سخت‌افزارها را به عهده دارد. در 
\lr{package} 
سیستم‌عامل یک 
\lr{package} 
به نام 
\lr{Scheduler} 
وجود دارد که وظیفه کلاس‌های موجود در آن، 
\lr{Schedule} 
کردن 
\lr{thread} 
هاست. همچنین یک 
\lr{package} 
به نام 
\lr{ScreenDriver} 
وجود دارد که وظیفه آن مدیریت سخت‌افزار 
\lr{Screen} 
است. در آینده نیز 
\lr{package} 
های 
\lr{MainMemoryManager} 
و 
\lr{FileSystem} 
به آن اضافه خواهد شد. همچنین در حال حاضر یک 
\lr{package} 
به نام 
\lr{ipc} 
در 
\lr{package} 
سیستم‌عامل وجود دارد که فعالیت‌های مربوط به ارتباط بین 
\lr{process} 
ها را انجام می‌دهد. 

این معماری طوری طراحی شده که نسبت به تغییرات احتمالی فازهای بعدی منعطف باشد. همچنین سادگی و طبیعی بودن آن موجب کم شدن تعداد باگ‌های منطقی می‌شود. به طور مثال فرض کنید می‌خواهیم یک دستور به زبان برنامه نویسی معرفی شده در تعریف پروژه اضافه کنیم. برای ساده شدن کامپایلر به جای شکستون دستور جدید به دستورات قدیمی(در صورت امکان)، یک 
\lr{instruction} 
جدید در سخت‌افزار تعریف می‌کنیم و کامپایلر را تغییر می‌دهیم تا بتواند آن دستور جدید را نیز تشخیص داده و 
\lr{instruction} 
مربوط به آن‌ را بسازد. سپس اگر این دستور نیاز به 
\lr{System Call} 
داشت کافی‌است 
\lr{System Call} 
مورد نیاز را در کد سیستم‌عامل پیاده سازی کنیم. با انجام همین چند کار، یک دستور به زبان برنامه نویسی اضافه می‌شود. 

\section{کلاس‌های مربوط به این فاز}
کلاس‌های مربوط به این فاز عبارت اند از: 
\begin{itemize} 
\item
کلاس 
\lr{SecondaryMemory}: 
این کلاس وظیفه نگهداری داده‌های موجود در 
\lr{secondary memory} 
را دارد. این کلاس فقط می‌تواند 
\lr{read} 
و 
\lr{write} 
انجام دهد و کار دیگری از آن ساخته نیست. 
در 
\lr{package} 
سخت‌افزار
\item
کلاس 
\lr{SecondaryMemoryDriver} 
در 
\lr{os.secondarymemory}:
این کلاس مسئولیت برقراری ارتباط با سخت‌افزار را دارد. در تمام سیستم عامل، هر چیزی که بخواهد به طور مستقیم و بدون هیچ واسطه‌ای با سخت افزار 
\lr{secondary memory} 
ارتباط برقرار کند، باید از این کلاس استفاده کند. 
\item 
کلاس 
\lr{BasicSecondaryMemoryManager} 
در 
\lr{os.secondarymemory}: 
این کلاس وظیفه خواندن و نوشتن به صورت بلوکی در 
\lr{secondary memory} 
را دارد. این کلاس چیزی درباره فایل‌ها نمی‌داند و فقط داده‌ها را به صورت بلوکی می‌خواند و می‌نویسد. 
\item 
کلاس 
\lr{FileManager} 
در 
\lr{os.secondarymemory}: 
این کلاس تمام مدیریت مربوط به فایل‌ها را انجام می‌دهد. از جمله ساخت فایل، خواندن فایل، نوشتن در فایل، پاک کردن فایل و ... . این کلاس برای تمام 
\lr{functionality} 
های خود از کلاس 
\lr{BasicSecondaryMemoryManager} 
استفاده می‌کند. 
\end{itemize}

\end{document}
